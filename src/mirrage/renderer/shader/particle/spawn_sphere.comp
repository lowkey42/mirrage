#version 450
#extension GL_ARB_separate_shader_objects : enable

#include "base_particle_script.glsl"

layout (local_size_x = 32, local_size_y = 1, local_size_z = 1 ) in;

layout(push_constant) uniform Push_constants {
	vec4 parent_velocity;
	vec4 position;
	vec4 rotation_quat;

	Random_float ttl;
	Random_float velocity;

	uint offset;
	uint to_spawn;
	uint base_seed;
	uint feedback_buffer_id;
	float timestep;
} emitter_cfg;

void main() {
	uint invId = gl_GlobalInvocationID.x;

	if(invId < emitter_cfg.to_spawn) {
		uint index = emitter_cfg.offset + invId;

		uint seed = hash(uvec2(emitter_cfg.base_seed, index));
		vec2 r01 = normal_rand(seed, 0, 1);

		float rand_ttl = rand_float(emitter_cfg.ttl, r01[0]);
		float rand_vel = rand_float(emitter_cfg.velocity, r01[1]);

		pout.particles[index].position.w = uintBitsToFloat(emitter_cfg.feedback_buffer_id);
		pout.particles[index].velocity.w = uintBitsToFloat(seed);
		pout.particles[index].ttl = vec4(rand_ttl, rand_ttl, 0, 0);

		vec3 dir = vec3(0,1,0); // TODO: random dir
		dir = quaternion_rotate(dir, emitter_cfg.rotation_quat);

		vec3 pos = emitter_cfg.position.xyz + dir;
		vec3 velocity = dir*rand_vel + emitter_cfg.parent_velocity.xyz;

		pos += velocity * emitter_cfg.timestep*(float(invId)/float(emitter_cfg.to_spawn));

		// TODO: take euler step of timestep*(float(invId)/float(emitter_cfg.to_spawn))
		//			might distribute particles more evenly => test it first

		pout.particles[index].position.xyz = pos;
		pout.particles[index].velocity.xyz = velocity;


	}
}
