#version 450
#extension GL_ARB_separate_shader_objects : enable

#include "base_particle_script.glsl"

layout (local_size_x = 32, local_size_y = 1, local_size_z = 1) in;

layout(std140, set=1, binding = 0) readonly buffer Particle_type_config {
	PARTICLE_TYPE_CONFIG
} particle_config;


layout(push_constant) uniform Push_constants {
	float timestep;
	uint particle_read_offset;
	uint particle_read_count;

	uint effector_count;
	uint effector_offset;
} update_cfg;


void main() {
	uint offset = gl_GlobalInvocationID.x;

	if(offset < update_cfg.particle_read_count) {
		uint index = offset + update_cfg.particle_read_offset;

		vec2 ttl = pin.particles[index].ttl.xy;
		ttl[0] -= update_cfg.timestep;

		if(ttl[0] <= 0) {
			// dead => drop data
		} else {
			const float dt = update_cfg.timestep;

			// incr count and get output index
			uint old_feedback_index = floatBitsToUint(pin.particles[index].position.w);
			uint feedback_index = feedback_mapping.new_feedback_index[old_feedback_index];
			uint out_offset = atomicAdd(feedback.ranges[feedback_index].count, 1);
			uint out_index = out_offset + feedback.ranges[feedback_index].offset;

			// update keyframe
			float age = ttl[1] - ttl[0];
			uint keyframe = 0;
			for(; keyframe+1<particle_config.keyframe_count-1; keyframe++) {
				if(particle_config.keyframes[keyframe].time >= age) {
					keyframe--;
					break;
				}
			}

			float time_a = particle_config.keyframes[keyframe].time;
			float time_b = particle_config.keyframes[min(keyframe+1, particle_config.keyframe_count-1)].time;
			float keyframe_t = clamp(0, 1, time_b <= time_a ? 0.0 : (age - time_a) / (time_b - time_a));

			// update position / velocity
			vec3 velocity = pin.particles[index].velocity.xyz;
			// TODO: velocity *= (1.0 - config.drag*dt);
			// TODO: apply global and local effectors

			pout.particles[out_index].position.xyz = pin.particles[index].position.xyz + velocity * dt;
			pout.particles[out_index].velocity.xyz = velocity;

			pout.particles[out_index].position.w = uintBitsToFloat(feedback_index);
			pout.particles[out_index].velocity.w = pin.particles[index].velocity.w;
			pout.particles[out_index].ttl = vec4(ttl.x, ttl.y, uintBitsToFloat(keyframe), keyframe_t);
		}
	}
}
