#version 450
#extension GL_ARB_separate_shader_objects : enable

#include "base_particle_script.glsl"

layout (local_size_x = 32, local_size_y = 1, local_size_z = 1) in;

layout(std140, set=1, binding = 0) uniform Config {
	Random_vec4 color; // hsva
	Random_vec4 color_change;

	Random_vec4 size;
	Random_vec4 size_change;

	Random_float sprite_rotation;
	Random_float sprite_rotation_change;

	float base_mass;
	float density;
	float drag;

	float timestep;
	uint particle_offset;
	uint particle_count;
	int padding;

	int effector_count;
	Effector effectors[];
} config;

#include "../global_uniforms.glsl"


void main() {
	uint offset = gl_GlobalInvocationID.x;

	if(offset < config.particle_count) {
		uint index = offset + config.particle_offset;

		vec2 ttl = pin.particles[index].ttl.xy;
		ttl[0] -= config.timestep;

		if(ttl[0] <= 0) {
			// dead => drop data
		} else {
			// incr count and get output index
			uint old_feedback_index = floatBitsToUint(pin.particles[index].position.w);
			uint feedback_index = feedback_mapping.new_feedback_index[old_feedback_index];
			uint out_offset = atomicAdd(feedback.ranges[feedback_index].count, 1);
			uint out_index = out_offset + feedback.ranges[feedback_index].offset;

			// update position / velocity
			vec3 velocity = pin.particles[index].velocity.xyz;
			velocity *= (1.0 - config.drag*config.timestep);
			// TODO: apply global and local effectors

			pout.particles[out_index].position.xyz = pin.particles[index].position.xyz + velocity * config.timestep;
			pout.particles[out_index].velocity.xyz = velocity;

			pout.particles[out_index].position.w = uintBitsToFloat(feedback_index);
			pout.particles[out_index].velocity.w = pin.particles[index].velocity.w;
			pout.particles[out_index].ttl = vec4(ttl.xy, 0, 0);
		}
	}
}
